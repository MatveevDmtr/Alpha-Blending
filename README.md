# Проект "Альфа-блендинг"
## Описание проекта
Основной целью данного проекта является тестирование оптимизаций для редактирования растровых изображений. Возьмем один из самых простых примеров обработки изобажений - попиксельное наложение 2-х картинок друг на друга c учетом прозрачности, или alpha-blending. Информацию об этом способе обработки изображений можно найти тут https://en.wikipedia.org/wiki/Alpha_compositing.
Реализуем такое наложение на С++ и посмотрим, как различные оптимизации влияют на время работы алгоритма.
## Инструменты и реализация
Для визуализации результата наложения будем использовать библиотеку SFML для C++.
Сначала напишем простую, "лобовую" реализацию алгоритма вычисления множества. С помощью модуля Clock библиотеки SFML будем засекать время, затрачиваемое на вычисление цветов пикселей с учетом прозрачности.
Для ускорения вычислений будем использовать Intrinsic functions, которые воплощают конвейерную реализацию вычислений с использованием AVX2 (Advanced Vector Extensions, расширение системы команд x86 процессоров Intel и AMD). Эти функции (Intrinsics) возьмем из библиотеки "immintrin.h" для C++.
Документации к этим функциям можно найти тут https://www.laruence.com/sse/.

## Реализованные функции
Релизовано 2 способа расчета цвета для пикселей картики с учетом прозрачности. Первый - обычный, для одиночных чисел, второй - с использованием 16-ти и 32-х байтных массивов и Intrinsic functions.
Формула рассчета компонент цвета (rgb) для каждого пикселя с учетом прозраности $a$:
$res_r = fr_r \cdot a + bk_r \cdot (255 - a)$
$res_g = fr_g \cdot a + bk_g \cdot (255 - a)$
$res_b = fr_b \cdot a + bk_b \cdot (255 - a)$
где $res_r$ - красная компонента результирующей картинки, $fr_g$ - зеленая компонента картинки переднего плана, $bk_b$ - синяя компонента картинки заднего плана. Остальные переменные в этих формулах трактуются аналогично.
В окне SFML реализована визуализация результата наложения.
Сама картинка выглядит следующим образом:
![result_img](./images/result/result.jpg)

## Автоматическая сборка
Чтобы запустить программу, необходимо использовать Makefile, прилагающийся к проекту. Для этого после клонирования этого репозитория на ваш компьютер  необходимо в теминале из папки репозитория набрать "make". В самом Makefile в переменной CFLAGS необходимо указать нужный тип оптимизации (см. ниже). Используя флаг условной компиляции -DDRAW  (см. Makefile) можно включать и выключать отрисовку множества, а с помощью флага -DMEASURING можно входить и выходить из режима измерений.

## Сборка вручную
Для компиляции программы необходимо прописать в терминале следующую команду:

```g++ -mavx2 -c -O3 -DDRAW alpha_blending.cpp -o alpha_blending.o```

Сборка проекта:

```g++ alpha_blending.o -o alpha_blending -lsfml-graphics -lsfml-window -lsfml-system```

Чтобы запустить программу, пропишите в терминале:

```./alpha_blending```

## Как достичь максимальной скорости вычислений? 

Проведем измерения FPS (количество кадров в секунду, что соответствует количеству рассчетов для полного наложения фотографий в секунду). Для повышения точности измерений будем усреднять значение FPS за первые 100 рассчетов множества. После 100-ой итерации в консоль выводится надпись "end of measuring". Значит, можно закрывать окно и считывать усредненное значение FPS, которое так же будет выведено в консоль сразу после закрытия окна.
Число 100 выбрано экспериментально по соотношению "время тестирования-точность результата". При желании в коде можно изменять число измерений (константа NUM_MEASURES).

В процессе измерений важно не двигать мышкой, не нажимать кнопки клавиатуры и не нагружать процессор другими способами. Эти сторонние факторы могут исказить результаты измерений.
Для упрощения измерений запустим функции рассчета с AVX и без AVX последовательно друг за другом, вычисляя FPS отдельно для каждой функции.

Так как FPS получается достаточно большим, будем записывать в таблицу значение, в 100 раз меньшее реального значения.

### С отрисовкой

| Флаг оптимизации |       AVX2, fps/100    |  Без AVX2, fps/100   | Ускорение, раз |
| :------:         | :---------------:  | :------------:   | :------------: |
|    none          |       19.3        |       18.7       |       1.03     |
|    -O3           |       72.7        |       42.9       |       1.7     |
|   -Ofast         |       126.8        |       78.4      |       0.68     |

В графе "Ускорение" указано, во сколько раз использование AVX ускорило расчет по сравнению с одиночными вычислениями $\textit{при неизменном флаге компиляторной оптимизации}$.

Теперь программно уберем отрисовку (сделаем пустое окно) и посмотрим, какого ускорения мы сможем достичь в этом случае.
Чтобы не происходило эффекта ликвидации всего кода, поставим volatile на переменные, влияющие на расчет.

### Без отрисовки
Проведем замеры FPS для разных оптимизаций при отключенной отрисовке. 
| Флаг оптимизации |       AVX2, fps/100        |    Без AVX2, fps/100    | Ускорение, раз |
| :------:         | :---------------: | :------------: | :------------: |
|       none       |       21.5        |       20.0     |       1.08     |
|       -O1        |       119.7       |       20.0     |       6.0     |
|       -O2        |       129.8       |       57.9     |       2.2     |
|       -O3        |       127.8       |       75.0    |       1.7     |
|       -Ofast     |       129.0      |       76.4    |       1.7     |

В графе "Ускорение" указано, во сколько раз использование AVX ускорило расчет по сравнению с одиночными вычислениями $\textit{при неизменном флаге компиляторной оптимизации}$.

Отключение отрисовки практически не изменило времени работы программы.

## Сравнение результатов и выводы
Итого, мы получили, что использование AVX2 оказывается практически всегда быстрее, чем обычная реализация алгоритма с одиночными числами. Так, AVX2 в некоторых случаях ускоряет алгоритм до 6 раз (с флагом -О1). Соотношение времен работы алгоритма с AVX и без AVX сильно зависит от типа компиляторной оптимизации, примененной на стадии компиляции проекта. При отсутствии компиляторной оптимизации (флаг -O0) реализации с AVX и без AVX показывают примерно одинаковые скорости вычислений.

Чтобы объяснить такой результат, посмотрим на результат компиляции программы при помощи godbolt.org. Оказывается, что при использовании AVX с флагом компиляции -О0 оптимизации присутствует приличное количество пересылок по памяти. Поэтому время работы алгоритма практически не отличается с AVX и без AVX.

Таким образом, конвейерные оптимизации почти всегда оказываются лучше одиночных вычислений. Однако, максимального ускорения удается достичь именно при флаге компиляции -О1, поэтому в каждом конкретном случае необходимо учитывать специфику задачи и использовать те инструменты оптимизации, которые проявят себя лучше всего.

Также заметим, что результаты -О2 в некоторых случаях оказываются лучше, чем -О3 и -Оfast. Скорее всего, это связано с тем, что погрешность измерений достаточно велика и она покрывает разницу между флагами компиляции. В любом случае, разница между -О2, -О3 и -Оfast не превышает прогрешности. Поэтому при выборе флага компиляции можно использовать более безопасный флаг компиляции, не опасаясь ухудшения производительности программы.

Также необходимо отметить, что результаты измерений fps сильно зависят от многих факторов: от типа и модели процессора, от его загруженности и даже температуры. Результаты, представленные в работе, соответствуют запуску программы на процессоре Intel Core i5 при использовании Linux Mint 21. Все результаты получены при соблюдении практически одинаковых внешних условий. Результаты измерений могут количественно отличаться в зависимости от условий запуска программы, но все качественные зависимости и тенденции, отмеченные в работе, сохранятся.